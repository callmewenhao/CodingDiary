# 经典动态规划：完全背包问题

给定不同面额的硬币 `coins` 和一个总金额 `amount`，写一个函数来计算可以凑成总金额的硬币组合数。**假设每一种面额的硬币有无限个**。

比如说输入 `amount = 5, coins = [1,2,5]`，算法应该返回 4，因为有如下 4 种方式可以凑出目标金额：

```c++
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1
```

如果输入的 `amount = 5, coins = [3]`，算法应该返回 0，因为用面额为 3 的硬币无法凑出总金额 5。

**我们可以把这个问题转化为背包问题的描述形式**：

有一个背包，最大容量为 `amount`，有一系列物品 `coins`，每个物品的重量为 `coins[i]`，**每个物品的数量无限**。请问有多少种方法，能够把背包恰好装满？

这个问题和我们前面讲过的两个背包问题，有一个最大的区别就是，每个物品的数量是无限的，这也就是传说中的「**完全背包问题**」，没啥高大上的，无非就是状态转移方程有一点变化而已。

下面就以背包问题的描述形式，继续按照流程来分析。

### 解题思路

**第一步要明确两点，「状态」和「选择」**。

状态有两个，就是「背包的容量」和「可选择的物品」，选择就是「装进背包」或者「不装进背包」嘛，背包问题的套路都是这样。

**第二步要明确 `dp` 数组的定义**。

首先看看刚才找到的「状态」，有两个，也就是说我们需要一个二维 `dp` 数组。

`dp[i][j]` 的定义如下：

若只使用前 `i` 个物品（可以重复使用），当背包容量为 `j` 时，有 `dp[i][j]` 种方法可以装满背包。

换句话说，翻译回我们题目的意思就是：

**若只使用 `coins` 中的前 `i` 个硬币的面值，若想凑出金额 `j`，有 `dp[i][j]` 种凑法**。

经过以上的定义，可以得到：

base case 为 `dp[0][..] = 0， dp[..][0] = 1`。因为如果不使用任何硬币面值，就无法凑出任何金额；如果凑出的目标金额为 0，那么“无为而治”就是唯一的一种凑法。

我们最终想得到的答案就是 `dp[N][amount]`，其中 `N` 为 `coins` 数组的大小。

**第三步，根据「选择」，思考状态转移的逻辑**。

注意，我们这个问题的特殊点在于物品的数量是无限的，所以这里和之前写的 [0-1 背包问题](https://labuladong.github.io/algo/3/26/81/) 文章有所不同。

**如果你不把这第 `i` 个物品装入背包**，也就是说你不使用 `coins[i-1]` 这个面值的硬币，那么凑出面额 `j` 的方法数 `dp[i][j]` 应该等于 `dp[i-1][j]`，继承之前的结果。

**如果你把这第 `i` 个物品装入了背包**，也就是说你使用 `coins[i-1]` 这个面值的硬币，那么 `dp[i][j]` 应该等于 `dp[i][j-coins[i-1]]`。

`dp[i][j-coins[i-1]]` 也不难理解，如果你决定使用这个面值的硬币，那么就应该关注如何凑出金额 `j - coins[i-1]`。

比如说，你想用面值为 2 的硬币凑出金额 5，那么如果你知道了凑出金额 3 的方法，再加上一枚面额为 2 的硬币，不就可以凑出 5 了嘛。

**综上就是两种选择，而我们想求的 `dp[i][j]` 是「共有多少种凑法」，所以 `dp[i][j]` 的值应该是以上两种选择的结果之和**：

```c++
int change(int amount, vector<int>& coins) {
    int n = coins.size();
    vector<vector<int>> dp(n+1, vector<int>(amount+1, 0));
    // basecase
    for(int i = 0; i < n+1; i++) {
        dp[i][0] = 1;
    }

    // dp
    for(int i = 1; i < n+1; i++){
        for(int j = 1; j < amount+1; j++){
            if(j < coins[i-1]) dp[i][j] = dp[i-1][j]; // 不能装下coins[i-1]
            else dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]];
        }
    }
    return dp[n][amount];
}
```












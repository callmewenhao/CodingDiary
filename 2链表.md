## 链表

### 链表介绍

单向链表(singly linked list)，每个节点有一个 next 指针指向后一个节点，还有一个成员变量用以储存数值;

双向链表(Doubly Linked List)，还有一个 prev 指针指向前一个节点。

Search: O(n), Del&Add: O(1)

### 直接删除当前节点

### DummyNode技巧

**考虑:**

1. 哪个节点的next指针会受到影响，则需要修正该指针
2. 如果待删除节点是动态开辟的内存空间，则需要释放这部分空间(C/C++)

利用dummy node是一个非常好用的trick：只要涉及操作head节点，当头节点操作不确定的时候，不妨创建`dummy node`:

```c++
ListNode *dummy = new ListNode(0);
dummy->next = head;
```

### 追赶(快慢)指针技巧

对于寻找list某个特定位置的问题，不妨用两个变量chaser与runner，以不同的速度遍历list，找到目标位置: ListNode *chaser = head,*runner = head。并且可以用一个简单的小test case来验证（例如长度为4和5的list)

### 模式识别

**1.**

在遍历Linked list时，注意每次循环内只处理一个或一对节点。

核心的节点只处理当前这一个，否则很容易出现重复处理的问题。

### 模式识别

**2. Swap Node 问题**

交换两个节点，不存在删除的话，两个节点的 prev 节点的 next 指针，以及这两个节点的 next 指针，会受到影响。总是可以：

- 先交换两个prev节点的next指针的值;
- 再交换这两个节点的next指针的值。

无论这两个节点的相对位置和绝对位置如何，以上的处理方式总是成立！

### 工具箱

对C++：
Doubly linked list的实现类是std::list<T>.常用iterator: begin(), end(), rbegin(), rend().常用函数:

empty(), size(), push_back(T value), pop_back(T value);erase(iterator pos), insert(iterator pos,T value);

对于Java：

Doubly linked list的实现类是LinkedList<E>常用函数:

add(E e), add(int index, E element), remove(int index),addAll(Collection<? Extends E>c),get(int index),

## 时空复杂度分析

> [阅读原文](https://mp.weixin.qq.com/s/OQAzopRncZe5cb9_of4mCQ)

1. Big O 表示法的几个基本特点。

2. 非递归算法中的时间复杂度分析。

3. 数据结构 API 的效率衡量方法（摊还分析）。

4. 递归算法的时间/空间复杂度的分析方法，这部分是重点，我会用动态规划和回溯算法举例。

### Big O 表示法

Big O 记号的数学定义：

> `O(g(n))`= {`f(n)`: 存在正常量`c`和`n_0`，使得对所有`n ≥ n_0`，有`0 ≤ f(n) ≤ c*g(n)`}

我们常用的这个符号`O`其实代表一个函数的集合，比如`O(n^2)`代表着一个由`g(n) = n^2`派生出来的一个函数集合；我们说一个算法的时间复杂度为`O(n^2)`，意思就是描述该算法的复杂度的函数属于这个函数集合之中。

**理论上，你看明白这个抽象的数学定义，就可以解答你关于 Big O 表示法的一切疑问了**。

**1、只保留增长速率最快的项，其他的项可以省略**。

```c++
// 乘法和加法中的常数因子都可以忽略不计
O(2N + 100) = O(N)
O(2^(N+1)) = O(2 * 2^N) = O(2^N)
O(M + 3N + 99) = O(M + N)
// 有的常数消不得
O(2^(2N)) = O(4^N)
// 增长速率慢的项在增长速率快的项面前也可以忽略不计
O(N^3 + 999 * N^2 + 999 * N) = O(N^3)
O((N + 1) * 2^N) = O(N * 2^N + 2^N) = O(N * 2^N)
```

**2、Big O 记号表示复杂度的「上界」**。

有些算法的复杂度会和算法的输入数据有关，没办法提前给出一个特别精确的时间复杂度，那么在这种情况下，用 Big O 记号扩大时间复杂度的上界就变得有意义了。

### 非递归算法分析

非递归算法的空间复杂度一般很容易计算，看它有没有申请数组之类的存储空间就行了。

非递归算法中嵌套循环很常见，大部分场景下，只需把每一层的复杂度相乘就是总的时间复杂度。


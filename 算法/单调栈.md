# 单调栈

## 引入

何为单调栈？顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。

单调栈分为**单调递增栈**和**单调递减栈**

- 单调递增栈：**单调递增**栈就是**从栈底到栈顶**数据是从大到小
- 单调递减栈：**单调递减**栈就是**从栈底到栈顶**数据是从小到大

## 模拟单调栈的数据 push 和 pop

以单调递增栈为例：

现在有一组数10，3，7，4，12。从左到右依次入栈，则如果栈为空或入栈元素值小于栈顶元素值，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。

10入栈时，栈为空，直接入栈，栈内元素为10。

3入栈时，栈顶元素10比3大，则入栈，栈内元素为10，3。

7入栈时，栈顶元素3比7小，则栈顶元素出栈，此时栈顶元素为10，比7大，则7入栈，栈内元素为10，7。

4入栈时，栈顶元素7比4大，则入栈，栈内元素为10，7，4。

12入栈时，栈顶元素4比12小，4出栈，此时栈顶元素为7，仍比12小，栈顶元素7继续出栈，此时栈顶元素为10，仍比12小，10出栈，此时栈为空，12入栈，栈内元素为12。

## 题目举例

### 一次单调栈

寻找数组中元素右侧以及左侧第一个大于它的数字：`1， 0， 2， 5， 3， 2， 6， 9`

1. 寻找左侧第一个大于它的数字

    构造一个单调递减栈：用来存储数据 `stack` ，存储伪代码如下：

    ```python
    insert x
    while !sta.empty() && sta.top()<x // 把小于x的元素pop出来
        sta.pop()
    sta.push(x) // 然后push进x
    ```

    我们从左侧开始遍历，对每一个元素执行上述代码，则左侧第一个大于它的数字就是 `while` 结束后的栈顶元素（若栈为空，就是没有这样的元素）

2. 寻找右侧第一个大于它的数字，和上述一样的道理，只是要从右侧开始遍历。

### 两次单调栈

[下一个更大元素 IV](https://leetcode.cn/problems/next-greater-element-iv/description/)

这个题目中使用了两次单调栈，来寻找 **第二大** 整数。

```C++
vector<int> secondGreaterElement(vector<int>& nums) {
        int n = nums.size();
        vector<int> ans(n, -1); // 初始化答案，元素为-1

        std::stack<int> st1;
        std::stack<int> st2; // 两个栈

        for (int i = 0; i < n; ++i) {
            while(!st2.empty() && nums[st2.top()] < nums[i]) {
                ans[st2.top()] = nums[i];
                // cout << "ans: " << nums[i] << endl;
                st2.pop();
            }
            std::vector<int> buff;
            while (!st1.empty() && nums[st1.top()] < nums[i]) {
                // cout << "pop st1 " << st1.top() << " " << nums[i] << endl;
                buff.push_back(st1.top());
                st1.pop();
            }
            st1.push(i);
            for (int j = buff.size() - 1; j >= 0; --j) {
                st2.push(buff[j]);
            }
        }
        return ans;
    }
```


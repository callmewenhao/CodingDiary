# 正则表达式（java version）

## 基本介绍

1. 一个正则表达式，就是用某种模式去匹配字符串的一个公式。很多人因为它们看上去比较古怪而且复杂所以不敢去使用，不过，经过练习后,就觉得这些复杂的表达式写起来还是相当简单的，而且,一旦你弄懂它们，你就能把数小时辛苦而且易错的文本处理工作缩短在几分钟（甚至几秒钟）内完成

2. 老韩这里要特别强调,正则表达式不是只有 `java` 才有，实际上很多编程语言都支持正则表达式进行字符串操作!如图所示。

## 正则表达式语法

### 基本介绍

如果要想灵活的运用正则表达式，必须了解其中各种元字符的功能，元字符从功能上大致分为：

1. 限定符

2. 选择匹配符
3. 分组组合和反向引用符
4. 特殊字符
5. 字符匹配符
6. 定位符

### 转义号

符号说明：在我们使用正则表达式去检索某些特殊字符的时候，需要用到转义符号 `\\`，否则检索不到结果，甚至会报错。在 Java 的正则表达式中，`\\` 代表其他语言中的一个 `\`

需要用到转义符号的字符有以下：`.*+()$/\?[ ] 1{}`

### 字符匹配符

| 符号  | 符号                                                 | 示例           | 解释                                                 |
| ----- | ---------------------------------------------------- | -------------- | ---------------------------------------------------- |
| `[]`  | 可接收的字符列表                                     | `[efgh]`       | e、f、g、h 中的任意1个字符                           |
| `[^]` | 不接收的字符列表                                     | `[^abc]`       | 除a、b、c之外的任意1个字符，包括数字和特殊符号       |
| `-`   | 连字符                                               | `A-Z`          | 任意单个大写字母                                     |
| `.`   | 匹配除`\n`以外的任何字符                             | `a..b`         | 以a开头，b结尾，中间包括2个任意字符的长度为4的字符串 |
| `\\d` | 匹配单个数字字符，相当于`[0-9]`                      | `\\d{3}(\\d)?` | 包含3个或4个数字的字符串                             |
| `\\D` | 匹配单个非数字字符，相当于`[^0-9]`                   | `\\D(\\d)*`    | 以单个非数字字符开头，后接任意个数字字符串           |
| `\\w` | 匹配单个数字、大小写字母字符相当于`[0-9a-zA-Z]`      | `\\d{3}\\w{4}` | 以3个数字字符开头的长度为7的数字字母字符串           |
| `\\W` | 匹配单个非数字、大小写字母字符，相当于`[^O-9a-zA-Z]` | `\\W+\\d{2}`   | 以至少1个非数字字母字符开头，2个数字字符结尾的字符串 |

`java` 正则表达式默认是区分字母大小写的，如何实现不区分大小写

1. `(?i)abc` 表示 `abc` 都不区分大小写

2. `a(?i)bc` 表示 `bc` 不区分大小写

3. `a((?i)b)c` 表示只有 `b` 不区分大小写

### 选择匹配符

在匹配某个字符串的时候是选择性的，即：既可以匹配这个，又可以匹配那个，这时你需要用到选择匹配符号`|`

### 限定符

用于指定其前面的字符和组合项连续出现多少次

| 符号    | 含义                                           | 示例          | 说明                                                |
| ------- | ---------------------------------------------- | ------------- | --------------------------------------------------- |
| `*`     | 指定字符重复0次或n次(无要求)                   | `(abc)*`      | 仅包含任意个 `abc` 的字符串，等效于`\\w*`           |
| `+`     | 指定字符重复1次或n次(至少1次)                  | `m+(abc)*`    | 以至少1个`m`开头，后接任意个`abc`的字符串           |
| `?`     | 指定字符重复0次或1次(最多1次)                  | `m+abc?`      | 以至少1个`m`开头，后接`ab`或`abc`的字符串           |
| `{n}`   | 只能输入n个字符                                | `[abcd]{3}`   | 由`abcd`中字母组成的任意长度为3的字符串             |
| `{n,}`  | 指定至少n个匹配                                | `[abcd]{3,}`  | 由`abcd`中字母组成的任意长度不小于3的字符串         |
| `{n,m}` | 指定至少n个但不多于m个匹配，会尽可能的匹配多个 | `[abcd]{3,5}` | 由`abcd`中字母组成的任意长度不小于3,不大于5的字符串 |

### 定位符

定位符，规定要匹配的字符串出现的位置，比如在字符串的开始还是在结束的位置，这个也是相当有用的，必须掌握

| 符号  | 含义                   | 示例               | 说明                                                         |
| ----- | ---------------------- | ------------------ | ------------------------------------------------------------ |
| `^`   | 指定起始字符           | `^[0-9]+[a-z]*`    | 以至少1个数字开头，后接任意个小写字母的字符串                |
| `$`   | 指定结束字符           | `^[0-9]\\-[a-z]+$` | 以1个数字开头后接连字符“-”，并以至少1个小写字母结尾的字符串  |
| `\\b` | 匹配目标字符串的边界   | `han\\b`           | 这里说的字符串的边界指的是**子串间有空格**，或者是**目标字符串的结束位置** |
| `\\B` | 匹配目标字符串的非边界 | `han\\B`           | 和`\\b`的含义刚刚相反                                        |

### 捕获分组

| 常用分组构造形式   | 说明                                                         |
| ------------------ | ------------------------------------------------------------ |
| `(pattern)`        | 非命名捕获。捕获匹配的子字符串。编号为零的第一个捕获是由整个正则表达式模式匹配的文本，其它捕获结果则根据左括号的顺序从1开始自动编号。 |
| `(?<name>pattern)` | 命名捕获。将匹配的子字符串捕获到一个组名称或编号名称中。用于name的字符串不能包含任何标点符号，并且不能以数字开头。可以使用单引号替代尖括号，例如`(?'name')` |

### 非捕获分组

| 常用分组构造形式 | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| `(?:pattern)`    | 匹配`pattern`但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用"or"字符组合模式部件的情况很有用。例如，`industr(?:y|ies)`是比`industry|industries`更经济的表达式。 |
| `(?=pattern)`    | 它是一个非捕获匹配。例如，`Windows (?=95|98|NT|2000)` 匹配 `Windows 2000`中   的 `Windows`，但不匹配 `Windows 3.1` 中的 `Windows`。 |
| `(?!pattern)`    | 该表达式匹配不处于匹配 pattern 的字符串的起始点的搜索字符串。它是一个非捕获匹配。例如，`Windows (?!95|98|NT|2000)` 匹配 `Windows 3.1` 中的 `Windows`，但是不匹配 `Windows 2000` 中的 `Windows` |

### 非贪婪匹配

符号：`?`

当此字符紧随任何其他限定符`(*、+、?、{n}、{n,}、{n,m})`之后时，匹配模式是"非贪心的"。"非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。例如，在字符串`oooo`中，`"o+?"`只匹配单个`"o"`，而`"o+"`匹配所有`"o"`。

## 应用实例

```java
// 汉字
String s1 = "^[\u0391-\uffe5]$"; // 这是全匹配
// 邮政编码 要求:是1-9开头的一个六位数。比如:123890
String s2 = "^[1-9]\\d{5}$";
// QQ号码 要求:是1-9开头的一个(5位数-10位数)比如:12389 ,1345687
String s3 = "^[1-9]\\d{4, 9}$";
// 手机号码 要求:必须以13,14,15,18 开头的11位数，比如13588889999
String s4 = "^1[3|4|5|8]\\d{9}$";
```

**验证复杂URL**

```java
String content = "https://www.bilibili.com/video/BV1Eq4y1E79W?p=17 " +
                "https://github.com/callmewenhao " +
                "https://github.com " +
                "https://leetcode.cn/problems/move-zeroes/ ";

String regStr = "(http|https)://([\\w-]+\\.)+[\\w-]+(\\/[\\w-?#@!*~=&/%.]*)?";

Pattern pattern = Pattern.compile(regStr);
Matcher matcher = pattern.matcher(content);
while (matcher.find()) {
    System.out.println(matcher.group(0));
}
```


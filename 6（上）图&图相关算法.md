# 图

> labuladong：面试笔试很少出现图相关的问题，就算有，大多也是简单的遍历问题，基本上可以完全照搬多叉树的遍历。适用于树的 DFS/BFS 遍历算法，全部适用于图。

## 图介绍

图是节点集合的一个拓扑结构，节点之间通过边相连。图分为有向图和无向图。

有向图的边具有指向性，即A->B仅表示由A到B的路径，但并不意味着B可以连到A。

与之对应地，无向图的每条边都表示一条双向路径：A-B

#### 表示方式

图的数据表示方式也分为两种，即邻接表（adjacency list）和邻接矩阵（adjacency matrix）

<img src="images\g0.jpg" height="100" width="150">

<img src="images\g1.jpeg" height="150" width="300">

邻接表很直观，我把每个节点 `x` 的邻居都存到一个列表里，然后把 `x` 和这个列表关联起来，这样就可以通过一个节点 `x` 找到它的所有相邻节点。

> 邻接表相比邻接矩阵更节省空间，但是时间开销比邻接矩阵大，比如说我想判断节点 `1` 是否和节点 `3` 相邻，我要去邻接表里 `1` 对应的邻居列表里查找 `3` 是否存在。但对于邻接矩阵就简单了，只要看看 `matrix[1][3]` 就知道了，效率高。

邻接矩阵则是一个二维布尔数组（注意，对于无向图它会是一个对称矩阵），我们权且称为 `matrix`，如果节点 `x` 和 `y` 是相连的，那么就把 `matrix[x][y]` 设为 `true`（上图中绿色的方格代表 `true`）。如果想找节点 `x` 的邻居，去扫一圈 `matrix[x][..]` 就行了。

> 在常规的算法题中，邻接表的使用会更频繁一些，主要是因为操作起来较为简单，但这不意味着邻接矩阵应该被轻视。矩阵是一个强有力的数学工具，图的一些隐晦性质可以借助精妙的矩阵运算展现出来。不过本文不准备引入数学内容，所以有兴趣的读者可以自行搜索学习。

### 顶点的度

在无向图中，「度」就是每个节点相连的边的条数。

由于有向图的边有方向，所以有向图中每个节点「度」被细分为**入度**（indegree）和**出度**（outdegree），比如下图：

<img src="images\g0.jpg" height="150" width="220">

其中节点 `3` 的入度为 3（有三条边指向它），出度为 1（它有 1 条边指向别的节点）。

### 图的分类

有向图，无向图，加权图，有向加权图等等……

**其实，这些更复杂的模型都是基于这个最简单的图衍生出来的**。

**有向加权图怎么实现**？

如果是邻接表，我们不仅仅存储某个节点 `x` 的所有邻居节点，还存储 `x` 到每个邻居的权重，不就实现加权有向图了吗？

如果是邻接矩阵，`matrix[x][y]` 不再是布尔值，而是一个 int 值，0 表示没有连接，其他值表示权重，不就变成加权有向图了吗？

### 图的遍历

多叉树（图和多叉树非常类似，不同在于图是带环的，而多叉树没环）的遍历框架如下：

```java
/* 多叉树遍历框架 */
void traverse(TreeNode root) {
    // 递归停止
    if (root == null) return;
	// 遍历所有子树并递归
    for (TreeNode child : root.children) {
        traverse(child);
    }
}
```

图和多叉树最大的区别是，图是可能包含环的，你从图的某一个节点开始遍历，有可能走了一圈又回到这个节点。

所以，如果图包含环，遍历框架就要一个 `visited` 数组进行辅助：

```java
// 记录被遍历过的节点
boolean[] visited;
// 记录从起点到当前节点的路径
boolean[] onPath;

/* 图遍历框架 */
void traverse(Graph graph, int s) {
    if (visited[s]) return;
    // 经过节点 s，标记为已遍历
    visited[s] = true;
    // 做选择：标记节点 s 在路径上
    onPath[s] = true;
    for (int neighbor : graph.neighbors(s)) {
        traverse(graph, neighbor);
    }
    // 撤销选择：节点 s 离开路径
    onPath[s] = false;
}
```

关于 `visited` 数组和 `onPath` 数组的区别，labuladong的[文章](https://labuladong.github.io/algo/2/20/36/)讲的很好

 `visited` 数组中的值代表顶点**是否被访问到过**

 `onPath` 数组代表着从**出发结点**到**当前结点**的路径（之间的结点以及他们自己）

如果让你处理路径相关的问题，这个 `onPath` 变量是肯定会被用到的，比如拓扑排序中就有运用。

## 广度优先（BFS）

按照层次向下遍历：遍历当前层，并把该层结点的子结点推入队列，依次访问队列中的元素

（配合队列实现）

<img src="F:\GithubRepository\CodingDiary\images\bfs.png" height="200" width="300">

#### BFS特点

搜索所有可以到达的状态，转移顺序为『初始状态->只需一次转移就可到达的所有状态->只需两次转移就可到达的所有状态->...』，所以对于同—个状态，BFS只搜索一次

BFS通常配合队列一起使用，搜索时先将状态加入到队列中，然后从队列顶端不断取出状态，同时把可从该状态转移到并且尚未访问过的状态加入队列，直到队列为空或已找到解。因此BFS适合用于『由近及远』的搜索，比较适合用于求解最短路径、最少操作之类的问题。

## 深度优先（DFS）

<img src="F:\GithubRepository\CodingDiary\images\dfs.png" height="200" width="350">

## 单源最短路径问题

对于每条边都有一个权值的图来说，单源最短路径问题是指从某个节点出发，到其他节点的最短距离。该问题的常见算法有Bellman-Ford和Dijkstra算法。

如果每条边权值相同（无权图），由于从源开始访问图遇到节点的最小深度就等于到该节点的最短路径，因此 Priority Queue就退化成Queue，Dijkstra算法就退化成BFS。

> 贪心思想

## All-pairs shortest paths

Floyd

## 回溯

DFS通常从某个状态开始，根据特定的规则转移状态，直至无法转移（节点为空），然后回退到之前一步状态，继续按照指定规则转移状态，直至遍历完所有状态。

回溯法包含了多类问题，模板类似。

排列组合模板->搜索问题(是否要排序，哪些情况要跳过)使用回溯法的一般步骤:

确定所给问题的解空间：首先应明确定义问题的解空间，解空间中至少包含问题的一个解。

确定结点的扩展搜索规则

以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。

















### 广度优先（BFS）

按照层次向下遍历：遍历当前层，并把该层结点的子结点推入队列，依次访问队列中的元素

（配合队列实现）

<img src="images\bfs.png" height="200" width="300">

#### BFS特点

搜索所有可以到达的状态，转移顺序为『初始状态->只需一次转移就可到达的所有状态->只需两次转移就可到达的所有状态->...』，所以对于同—个状态，BFS只搜索一次

BFS通常配合队列一起使用，搜索时先将状态加入到队列中，然后从队列顶端不断取出状态，同时把可从该状态转移到并且尚未访问过的状态加入队列，直到队列为空或已找到解。因此BFS适合用于『由近及远』的搜索，比较适合用于求解最短路径、最少操作之类的问题。

### 深度优先（DFS）

<img src="images\dfs.png" height="200" width="350">

### 单源最短路径问题

对于每条边都有一个权值的图来说，单源最短路径问题是指从某个节点出发，到其他节点的最短距离。该问题的常见算法有Bellman-Ford和Dijkstra算法。

如果每条边权值相同（无权图），由于从源开始访问图遇到节点的最小深度就等于到该节点的最短路径，因此 Priority Queue就退化成Queue，Dijkstra算法就退化成BFS。

> 贪心思想

### All-pairs shortest paths

Floyd

### 回溯

DFS通常从某个状态开始，根据特定的规则转移状态，直至无法转移（节点为空），然后回退到之前一步状态，继续按照指定规则转移状态，直至遍历完所有状态。

回溯法包含了多类问题，模板类似。

排列组合模板->搜索问题(是否要排序，哪些情况要跳过)使用回溯法的一般步骤:

确定所给问题的解空间：首先应明确定义问题的解空间，解空间中至少包含问题的一个解。

确定结点的扩展搜索规则

以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。


## 排序

### 内排序

内排序是指所有的数据已经读入内存，在内存中进行排序的算法。排序过程中不需要对磁盘进行读写。同时，内排序也一般假定所有用到的辅助空间也可以直接存在于内存中。

另一类排序称作外排序，即内存中无法保存全部数据，需要进行磁盘访问，每次读入部分数据到内存进行排序。

#### 冒泡排序

#### 插入排序

#### 希尔排序

#### 选择排序

#### Quick Sort（快速排序）

Quick sort 是最为常用的排序算法，算法核心与merge sort类似，也采用“分而治之”的想法：

随机选定一个元素作为轴值，利用该轴值将数组分为左右两部分，左边元素都比轴值小，右边元素都比轴值大，但它们不是完全排序的。在此基础上，分别对左右两部分分别递归调用quick sort，使得左右部分完全排序。

算法的平均时间复杂度是O(nlogn)，在最坏情况下为O(n^2)，额外空间复杂度O(logn)。

#### Merge Sort（归并排序）

Merge sort 是一种典型的排序算法，应用“分而治之(divide and conquer)”的算法思路：

将线性数据结构（如array, vector或list）分为两个部分，对两部分分别进行排序，排序完成后，再将各自排序好的两个部分合并还原成一个有序数组。由于 merge sort 不依赖于随机读写，因此具有很强的普适性，适用于list等数据结构。算法的时间复杂度O(nlogn)，需要额外O(n)空间。

https://leetcode-cn.com/problems/sort-list/

https://leetcode-cn.com/problems/sort-an-array/

```C++
/**
 * 归并排序模板
 * @param nums 待排序数组
 * @param temp 辅助数组，与 nums 大小相同
 * @param left 排序做边界
 * @param right 右边界
 */
void mergeSort(vector<int> &nums, vector<int> &temp, int left, int right) {
    if (left == right) return;
    // 中间值
    int mid = left + (right - left) / 2;
    mergeSort(nums, temp, left, mid); // 递归调用
    mergeSort(nums, temp, mid + 1, right);

    // 提前结束
    if (nums[mid] <= nums[mid + 1]) return;

    // 归并
    for (int i = left; i <= right; ++i) {
        temp[i] = nums[i];
    }
    int i = left, j = mid + 1;
    for (int k = left; k <= right; ++k) {
        if (i == mid + 1) {
            nums[k] = temp[j];
            j++;
        } else if (j == right + 1) {
            nums[k] = temp[i];
            i++;
        } else if (temp[i] <= temp[j]) {
            nums[k] = temp[i];
            i++;
        } else {
            nums[k] = temp[j];
            j++;
        }
    }
}
```

#### Counting Sort（计数排序）

> 一种稳定的线性时间排序算法
> 
> https://zhuanlan.zhihu.com/p/125126086

计数排序使用一个额外的数组，**其中第i个元素是待排序数组A中值等于i的元素的个数**，**核心**：将待排序列元素转化为**键值对**存储在额外开辟的数组空间中，这样开辟的数组其实就是一个排序序列。新数组的长度取决于待排序数组中数据的范围（待排序数组的最大值与最小值的差加上1）

注意：作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是**有确定范围的整数**。

时间复杂度：O(k+n)，空间复杂度为：O(k+n)

#### Bucket Sort（桶排序）

> https://zhuanlan.zhihu.com/p/164992268

**桶排序是所有排序中最简单的排序之一**

将待排序的序列按照**一定的规则**分到若干个桶中，每个桶内的元素再进行**桶内排序**（借助另一种排序方法，或者递归），最后遍历所有的桶得到排序序列。

假设有`n`个待排序数字。分到`m`个桶中，如果分配均匀这样平均每个桶有`n/m`个元素，算法时间复杂度有两部分组成：

- 遍历处理每个元素：O(n)

- 每个桶内再次排序的时间复杂度总和：
  
  假设每个桶内部使用的排序算法为**快速排序（nlogn）**，每个桶内的时间复杂度为`(n/m)log(n/m)`，有`m`个桶，那么时间复杂度为 `m * (n/m)log(n/m) = n(logn-logm)`

所以最终桶排序的时间复杂度为：`O(n)+O(n*(logn-logm))` = `O(n+n*(logn -logm))` 其中`m`为桶的个数

可见，桶排序是一种用空间换取时间的排序。

设计桶排序的时候即需要**待排序数列均匀**，又要求**桶的设计兼顾效率和空间**。

- 如果待排序数列不均匀，极限情况：一共n个元素，前n-1个元素被分配到一桶，第n个元素在另一桶，此时算法的时间复杂度就是：桶内排序的算法时间复杂度，没有得到优化！

- 如果设计的桶数目特别多：一共n个元素，设计1000*n只桶，一是空间浪费，另外遍历所有桶的时间花费也很大！

> 待排序列要分布相对均匀，桶的个数也要合理设计。总之桶排序是一种用空间换取时间的排序。在设计桶排序时，你需要知道输入数据的上界和下界，看看数据的分布情况，再考虑是否用桶排序

#### Radix Sort（基数排序）

> Bucket sort 和 Radix sort 不需要进行数据之间的两两比较，但是需要事先知道数组的一些具体情况。
> 
> https://www.jianshu.com/p/a1012fab9161

基数排序（Radix Sort）属于分配式排序，又称"桶子法"（Bucket Sort或Bin Sort），将待排序元素按一定规则分配到某些”桶“中，以达到排序的作用。

基数排序的方式可以采用**最低位优先LSD（Least sgnificant digital）法**或**最高位优先MSD（Most sgnificant digital）法**，LSD的排序方式由键值的最右边开始，而MSD则相反，由键值的最左边开始。LSD的基数排序适用于位数小的数列，如果位数多的话，使用MSD的效率会比较好，MSD的方式恰与LSD相反，是由高位数为基底开始进行分配，其他的演算方式则都相同。

### 外排序

假设文件需要分成k块读入，需要从小到大进行排序

1. 依次读入每个文件块，在内存中对当前文件块进行排序（应用恰当的内排序算法）。此时，每块文件相当于一个由小到大排列的有序队列

2. 在内存中建立一个最小值堆，读入每块文件的队列头

3. 弹出堆顶元素，如果元素来自第i块，则从第i块文件中补充一个元素到最小值堆。弹出的元素暂存至临时数组

4. 当临时数组存满时，将数组写至磁盘，并清空数组内容

5. 重复过程3. 4.，直至所有文件块读取完毕

### 堆和堆排序

> C++ 中的优先队列和堆的作用类似

**堆的定义**如下：n个元素的序列{k1,k2,k3...,kn}当且仅当满足下关系时，称之为堆。$k_i <= k_{2i}, k_i <= k_{2i+1}$ 或者 $k_i >= k_{2i}, k_i >= k_{2i+1}$

若将此序列对应的一维数组（即以一维数组作为此序列的存储结构）看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于（不小于）其左、右孩子结点的值。由此，堆顶元素（完全二叉树的根）必为序列中的最小值或最大值。

**堆排序**：若在输出堆顶的最小值之后，使得剩余 n-1 个元素的序列又重建成一个堆，则得到n个元素中的次小值。如此反复执行，便能得到一个有序序列，这个过程称之为堆排序。

#### 模式识别

当题目中出现“前K个”，“合并/排序k组数据”或者“数据流（即不知道全部数据，而是每次读入一个）”时，可以考虑使用heap，**动态地维护**最大值/最小值信息

# 线段树

[介绍](https://oi-wiki.org/ds/seg/) 线段树是算法竞赛中常用的用来维护 **区间信息** 的数据结构。线段树可以在 ![O(\log N)](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7) 的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值)等操作。

## 基本款线段树（二分）

单点修改、区间最值、区间求和

```C++
class SegTree {
public:
    vector<int> s; // 存放区间和
    vector<int> m; // 存放区间最小值

    SegTree(vector<int> &arr) {
        int n = arr.size();
        s.resize(4 * n, 0);
        m.resize(4 * n, 0);
        // 递归建树
        build(1, 1, n, arr);
    }

    /**
     * 建树函数
     * @param o 当前节点的在线段树数组中的位置
     * @param l 当前节点对应原数组中的左边界
     * @param r 当前节点对应原数组中的右边界
     * @param arr 原数组
     */
    void build(int o, int l, int r, vector<int> &arr) {
        if (l == r) {
            s[o] = arr[l - 1];
            m[o] = arr[l - 1];
            return;
        }
        int mid = l + (r - l) / 2;
        build(o * 2, l, mid, arr);
        build(o * 2 + 1, mid + 1, r, arr);

        s[o] = s[o * 2] + s[o * 2 + 1];
        m[o] = min(m[o * 2], m[o * 2 + 1]);
    }

    /**
     * 单点修改函数（递归函数）
     * @param o 当前节点的在线段树数组中的位置
     * @param l 当前节点对应原数组中的左边界
     * @param r 当前节点对应原数组中的右边界
     * @param idx 修改的位置
     * @param val 要加的值
     * 调用示例：add(1, 1, n, idx, val)
     */
    void add(int o, int l, int r, int idx, int val) {
        if (l == r) { // 递归停止的条件
            s[o] += val;
            m[o] += val;
            return;
        }
        int mid = l + (r - l) / 2;
        if (idx <= mid)
            add(o * 2, l, mid, idx, val);
        else
            add(o * 2 + 1, mid + 1, r, idx, val);
        s[o] = s[o * 2] + s[o * 2 + 1];
        m[o] = min(m[o * 2], m[o * 2 + 1]);
    }

    /**
     * 区间求和函数（递归函数）
     * @param o 当前节点的在线段树数组中的位置
     * @param l 当前节点对应原数组中的左边界
     * @param r 当前节点对应原数组中的右边界
     * @param L 查询区间的左边界
     * @param R 查询区间的右边界
     * @return 返回查询区间的和
     * 调用示例：add(1, 1, n, L, R)
     */
    int getSum(int o, int l, int r, int L, int R) {
        if (L <= l && r <= R) return s[o];
        int ans = 0;
        int mid = l + (r - l) / 2;
        if (L <= mid)
            ans += getSum(o * 2, l, mid, L, R);
        if (R > mid)
            ans += getSum(o * 2 + 1, mid + 1, r, L, R);
        return ans;
    }

    /**
     * 返回区间 [1, R] 中第一个小于等于 val 的下标
     * @param o 当前节点的在线段树数组中的位置
     * @param l 当前节点对应原数组中的左边界
     * @param r 当前节点对应原数组中的右边界
     * @param R 查询区间的右边界，对应区间 [1, R]
     * @param val 查询的临界值
     * @return 返回下标
     */
    int getFirstMinIdx(int o, int l, int r, int R, int val) {
        if (m[o] > val)
            return 0; // 没找到返回0
        if (l == r)
            return l; // 找到返回下标
        int mid = l + (r - l) / 2;
        if (m[o * 2] <= val) // 左区间
            return getFirstMinIdx(o * 2, l, mid, R, val);
        if (R > mid)
            return getFirstMinIdx(o * 2 + 1, mid + 1, r, R, val);
        return 0;
    }

    /**
     * 查询区间最小值
     * @param o 当前节点的在线段树数组中的位置
     * @param l 当前节点对应原数组中的左边界
     * @param r 当前节点对应原数组中的右边界
     * @param L 查询区间的左边界
     * @param R 查询区间的右边界
     * @return 返回区间最小值
     */
    int getMin(int o, int l, int r, int L, int R) {
        if (l == r) return m[o];
        int ans = INT_MAX;
        int mid = l + (r - l) / 2;

        if (L <= mid)
            ans = min(ans, getMin(o * 2, l, mid, L, R));
        if (mid < R)
            ans = min(ans, getMin(o * 2 + 1, mid + 1, r, L, R));
        return ans;
    }
}
```


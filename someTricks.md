# Some Tricks

#### 324å‘¨èµ›

1. C++ å¯ä»¥ä½¿ç”¨å˜é‡å£°æ˜æ•°ç»„é•¿åº¦

2. è®¡ç®—å‰ç¼€å’Œï¼š`std::partial_sum()`

    ```C++
    int n;
    std::cin >> n;
    int arr[n];
    std::iota(arr, arr + n, 1);
    std::vector<int> sum(n + 1, 0);
    std::partial_sum(arr, arr + n, sum.begin() + 1);
    ```

3. åˆ†è§£è´¨å› æ•°

    ```C++
    int k = 2; // ä»2å¼€å§‹é™¤
    std::vector<int> ans;
    while (k <= n) {
        if (n % k == 0) { // å¦‚æœkæ˜¯nçš„å› æ•°
            n /= k;
            ans.push_back(k);
        } else
            k++; // å¦‚æœæ­¤æ—¶kä¸æ˜¯nçš„å› æ•°ï¼Œå°†kå€¼åŠ 1
    }
    ```

4. Least Common Ancestors: æœ€è¿‘å…¬å…±ç¥–å…ˆé—®é¢˜

    



#### ç¦»çº¿æ€ç»´

ç®—æ³•å¯ä»¥ä»è¿™æ ·çš„ä¸€ä¸ªç»´åº¦åˆ†æˆä¸¤ç±»ï¼šåœ¨çº¿ç®—æ³•å’Œç¦»çº¿ç®—æ³•ã€‚


ä»€ä¹ˆå«åœ¨çº¿ç®—æ³•ï¼Ÿå°±æ˜¯ä¾æ¬¡å¤„ç†æ¯ä¸€ä¸ª queryï¼Œå¯¹æ¯ä¸€ä¸ª query çš„è®¡ç®—ï¼Œå’Œä¹‹åçš„ query æ— å…³ï¼Œä¹Ÿä¸ä¼šç”¨åˆ°ä¹‹åçš„ query ä¿¡æ¯ï¼ˆä½†å¯èƒ½ä¹Ÿå¯ä»¥ä½¿ç”¨ä¹‹å‰çš„ query ä¿¡æ¯ï¼‰ã€‚

æ‰€ä»¥ï¼Œåœ¨çº¿ç®—æ³•ï¼Œå¯ä»¥ç”¨æ¥å¤„ç†æ•°æ®æµã€‚ç®—æ³•ä¸éœ€è¦ä¸€æ¬¡æ€§åœ°æŠŠæ‰€æœ‰çš„ query éƒ½æ”¶é›†åˆ°å†å¤„ç†ã€‚å¤§å®¶ä¹Ÿå¯ä»¥æƒ³è±¡æˆï¼šæŠŠè¿™ä¸ªç®—æ³•ç›´æ¥éƒ¨ç½²åˆ°çº¿ä¸Šï¼Œå°½ç®¡åœ¨çº¿ä¸Šå¯èƒ½åˆäº§ç”Ÿäº†å¾ˆå¤šæ–°çš„ queryï¼Œä¹Ÿä¸å½±å“ï¼Œç®—æ³•ç…§å¸¸è¿è¡Œã€‚

ç¦»çº¿ç®—æ³•åˆ™ä¸åŒã€‚ç¦»çº¿ç®—æ³•éœ€è¦æŠŠæ‰€æœ‰çš„ä¿¡æ¯éƒ½æ”¶é›†åˆ°ï¼Œæ‰èƒ½è¿è¡Œã€‚å¤„ç†å½“å‰ query çš„è®¡ç®—è¿‡ç¨‹ï¼Œå¯èƒ½éœ€è¦ä½¿ç”¨ä¹‹å query çš„ä¿¡æ¯ã€‚

ä¸¾ä¸¤ä¸ªæœ€ç®€å•çš„ä¾‹å­æ¥è¯´æ˜ã€‚

ä»¥æ’åºç®—æ³•ä¸ºä¾‹ï¼Œæ’å…¥æ’åºç®—æ³•æ˜¯ä¸€ç§åœ¨çº¿ç®—æ³•ã€‚å› ä¸ºå¯ä»¥æŠŠæ’å…¥æ’åºç®—æ³•çš„å¾…æ’åºæ•°ç»„çœ‹åšæ˜¯ä¸€ä¸ªæ•°æ®æµã€‚æ’å…¥æ’åºç®—æ³•é¡ºæ¬¡æŠŠæ¯ä¸€ä¸ªæ•°æ®æ’å…¥åˆ°å½“å‰æ’å¥½åºæ•°ç»„éƒ¨åˆ†çš„æ­£ç¡®ä½ç½®ã€‚åœ¨æ’åºè¿‡ç¨‹ä¸­ï¼Œå³ä½¿åé¢æºæºä¸æ–­æ¥æ–°çš„æ•°æ®ä¹Ÿä¸æ€•ï¼Œæ•´ä¸ªç®—æ³•ç…§å¸¸è¿›è¡Œã€‚

é€‰æ‹©æ’åºç®—æ³•åˆ™æ˜¯ä¸€ç§ç¦»çº¿ç®—æ³•ã€‚å› ä¸ºé€‰æ‹©æ’åºç®—æ³•ä¸€ä¸Šæ¥è¦æ‰¾åˆ°æ•´ä¸ªæ•°ç»„ä¸­æœ€å°çš„å…ƒç´ ï¼›ç„¶åæ‰¾ç¬¬äºŒå°å…ƒç´ ï¼›ä»¥æ­¤ç±»æ¨ã€‚è¿™å°±è¦æ±‚ä¸èƒ½å†æœ‰æ–°çš„æ•°æ®äº†ã€‚å› ä¸ºåˆšæ‰¾åˆ°æœ€å°å…ƒç´ ï¼Œå†æ¥çš„æ–°æ•°æ®ä¸­æœ‰æ›´å°çš„å…ƒç´ ï¼Œä¹‹å‰çš„è®¡ç®—å°±ä¸æ­£ç¡®äº†ã€‚


å†ä¸¾ä¸€ä¸ªä¾‹å­ï¼Œå¯¹äº topK é—®é¢˜ï¼ˆæ‰¾å‰ k å°æˆ–è€…å‰ k å¤§çš„å…ƒç´ ï¼‰ã€‚

ä½¿ç”¨ä¸€ä¸ªå¤§å°ä¸º k çš„ä¼˜å…ˆé˜Ÿåˆ—æ˜¯åœ¨çº¿ç®—æ³•ï¼Œè™½ç„¶æ—¶é—´å¤æ‚åº¦æ˜¯ O(nlogk)ï¼Œä½†æ•´ä¸ªç®—æ³•ä¸éœ€è¦ä¸€æ¬¡æ€§çŸ¥é“æ‰€æœ‰çš„æ•°æ®ï¼Œå¯ä»¥å¤„ç†æ•°æ®æµï¼›

ä½¿ç”¨å¿«æ’çš„æ€æƒ³åšæ”¹è¿›ï¼ŒtopK é—®é¢˜å¯ä»¥åœ¨ O(n) æ—¶é—´è§£å†³ã€‚ä½†è¿™æ˜¯ä¸€ä¸ªç¦»çº¿çš„ç®—æ³•ã€‚åˆå§‹å¿…é¡»çŸ¥é“æ‰€æœ‰çš„æ•°æ®ï¼Œæ‰èƒ½å®Œæˆã€‚

#### initialize the set/unordered set with vector

```
unordered_set<int> st(nums.begin(), nums.end()); // æ‰€æœ‰å…ƒç´ åŠ å…¥å“ˆå¸Œè¡¨
```

#### Debug

```C++
#include <initializer_list>
template<class T>
void Debug(initializer_list<T> infos) {
    std::cout << "\nnew debug line:\n";
    for (auto& it: infos) {
        std::cout << it << " ";
    }
    std::cout << "\nend\n";
}
```

#### C++ lambda ä¸­è¿›è¡Œé€’å½’

C++ æ— æ³•åƒ python ä¸€æ ·åœ¨å‡½æ•°ä¸­å®šä¹‰æ™®é€šå‡½æ•°ï¼Œä½†å¯ä»¥ä½¿ç”¨ lambda å®ç°ã€‚æœ‰ä¸€ä¸ªåœºæ™¯æ˜¯åœ¨è¿™ä¸ªå†…éƒ¨åŒ¿åå‡½æ•°ä¸­è¿›è¡Œé€’å½’ï¼Œä½†ä¸€èˆ¬å®šä¹‰çš„ lambda å‡½æ•°æ— æ³•é€’å½’ï¼ˆå³ä½¿ä½ çš„æ•è·åˆ—è¡¨æ˜¯`[&]`ï¼‰ï¼Œå¦‚ä¸‹ï¼š

```C++
auto dfs = [&](){ // intuition!
	dfs(); // error: use of 'dfs' before deduction of 'auto'
};
```

è¿™æ˜¯å› ä¸º `åŒ¿å`å‡½æ•°çš„åŒ¿åç‰¹æ€§ğŸ¤£ï¼Œè¿™ä¸ªå‡½æ•°æ˜¯æ²¡æœ‰åå­—çš„ï¼Œæ— æ³•æ•è·

ä¸¤ç§è§£å†³æ–¹æ¡ˆï¼š

1. `std::function`ï¼Œè¿™ä¸ªå†™æ³•æ¯”è¾ƒ uglyï¼Œä»£ç å†—ä½™ï¼è¿˜æœ‰å…¶ä»–ç¼ºç‚¹ğŸ˜‚ä»¥åå†è¯´

```C++
#include <functional>
int main() {
    std::function<void()> dfs = [&](){
        dfs(); //OK
    };
    
    std::function<int(int)> fibonacci = [&](int n) -> int {
        if (n == 1 || n == 2) return 1;
        return fibonacci(n - 1) + fibonacci(n  -2);
    };

    std::cout << fibonacci(10) << std::endl;
}
```

2. Fixed-point combinatorï¼ŒåŠ›æ‰£ä¸Šç»™äº†ä¸€ä¸ªè§£å†³æ–¹æ¡ˆï¼šhttps://leetcode.cn/circle/discuss/nkNj76/ï¼Œä¸å¤ªå¥½æ‡‚ğŸ¤£

#### éå†ä¸€æ£µæ ‘ï¼ˆåŒå‘ã€æ— ç¯ã€è¿é€šï¼‰

```C++
// ç”¨ä¸€ä¸ªè¿”å›æ ‘æèŠ‚ç‚¹ä¸ªæ•°çš„ä»£ç ä¸¾ä¾‹
LL dfs(int node, int fa) { // nodeï¼šè¦éå†çš„èŠ‚ç‚¹ faï¼šçˆ¶èŠ‚ç‚¹
    int size = 1;
    for (auto sub_node: graph[node]) {
        if (sub_node != fa) { // è¿™æ ·å°±çœå»äº† visited æ•°ç»„
            size += dfs(sub_city, city, seats);
        }
    }
    return size;
}
```

#### åè½¬æ•°å­—

```c++
int reverseNum(int n) {
    int rev = 0;
    while (n != 0) {
        rev = rev * 10 + n % 10;
        n /= 10;
    }
    return rev;
}

// stringç‰ˆæœ¬
int reverseNum(int n) {
    std::string s = std::to_string(n);
    std::reverse(s.begin(), s.end());
    return std::stoi(s);
}
```

#### å»é‡å®¹å™¨ unordered_set

```c++
std::unordered_set<int> memo;
memo.insert(1);
memo.insert(1);
memo.insert(1);
std::cout << memo.size() << std::endl; // è¾“å‡ºï¼š1
```

#### `lowbit`

`lowbit`ï¼šå°†ä¸€ä¸ªæ•°æ‹†æˆæœ€å°ä¸ªæ•°çš„ `2^i` å’Œçš„å½¢å¼ï¼Œå…¶ä¸­çš„æœ€å°çš„é‚£ä¸ªï¼Œæ¯”å¦‚ï¼šäºŒè¿›åˆ¶æ•° 0010,0100 ä¸­çš„ 0000,0100ï¼Œè€Œä¸” `lowbit = n & -n;`

> çµç¥ï¼š`CSAPP` ä¸­æœ‰è®²åˆ°

ä¸€ä¸ªæŠŠæ•°æ‹†æˆæœ€å°ä¸ªæ•°çš„ `2^i` å’Œçš„å½¢å¼çš„å‡½æ•°

```c++
std::vector<int> lowbitFn(int n) {
    std::vector<int> ans;
    while (n) {
        int lowbit = n & -n;
        ans.push_back(lowbit);
        n ^= lowbit;
    }
    return ans;
}
```

#### æœ€å°åŒ–æœ€å¤§å€¼ => äºŒåˆ†ç­”æ¡ˆ

æœ€å°åŒ–æœ€å¤§å€¼åˆå«äºŒåˆ†ç­”æ¡ˆ

#### å‘ä¸Šå–æ•´

```
res = (a + b - 1) / b // ä½¿ç”¨é»˜è®¤çš„å‘ä¸‹å–æ•´
```

#### è¿ç»­å­åŒºé—´=>æ»‘åŠ¨çª—å£

#### ç»å…¸å¾ªç¯éå†=>å¾ªç¯æ•°ç»„ã€Œæ‹‰ç›´ã€

å°±æ˜¯è¯´ï¼ŒæŠŠå‰n-1ï¼ˆæˆ‘ç”¨äº†nä¸ªï¼‰ä¸ªå…ƒç´ æ‹¼åˆ°æ•°ç»„åé¢

ä½†æ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨%è¿ç®—æ¨¡æ‹Ÿè¿™ä¸ªè¿‡ç¨‹ï¼Œä¸å¿…çœŸçš„æ‹¼æ¥

#### ä¸‹ä¸€ä¸ªæœ€å¤§æ•°å­—=>å•è°ƒæ ˆ

#### å…³äº 0x3f

```c++
int a[10];
memset(a, 0x3f, sizeof a);

for (int i = 0; i < 10; ++i) {
    cout << a[i] << endl;
}
```

è¾“å‡ºå…¨éƒ¨æ˜¯ï¼š106110956ï¼Œ æ˜¯`10^9`çº§åˆ«çš„ï¼Œæ»¡è¶³ç®—æ³•é¢˜ç›®ä¸­æ•°æ®é‡çš„èŒƒå›´

#### GCD & LCM

C++ `<numeric>` ä¸­æœ‰ `std::gcd()` å‡½æ•°ç”¨äºè®¡ç®—**æœ€å¤§å…¬çº¦æ•°**ï¼Œ`std::lcm()` è®¡ç®—**æœ€å°å…¬å€æ•°**ï¼›Python3 `math` ä¸­ä¹Ÿæœ‰ `gcd` ã€`lcm` å‡½æ•°

è®¡ç®— GCD ä¸€ç§å¸¸è§æ–¹æ³•æ˜¯æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼Œå³è¾—è½¬ç›¸é™¤æ³•ï¼Œ ä»£ç å¦‚ä¸‹ï¼š

> https://zhuanlan.zhihu.com/p/171623230
>
> ä¸»è¦æ€æƒ³ï¼šgcd(a, b) = gcd(b, a mod b) (ä¸å¦¨è®¾a>b ä¸”r=a mod b ,rä¸ä¸º0)

```c++
// note: input parameters must be positive integer!
long long findGCD(long long a, long long b) {
    long long small_num = min(a, b);
    long long big_num = max(a, b);
    long long mod = big_num % small_num;
    if (mod == 0) return small_num;
    return findGCD(small_num, mod); 
    // there is a recursive method, 'while' loop is another way!
}
```

è®¡ç®— LCM å¯ä»¥ä½¿ç”¨ä¸¤æ•°ä¹˜ç§¯é™¤ä»¥ GCD è¿›è¡Œè®¡ç®—ï¼Œä»£ç ç•¥

#### åºåˆ—æœ‰åºçš„æœ€å°‘äº¤æ¢æ¬¡æ•°â€”â€”ä»»æ„äº¤æ¢å…ƒç´ ä½ç½®

æœ€å°‘äº¤æ¢æ¬¡æ•° = å…ƒç´ ä¸ªæ•° - ç¯çš„ä¸ªæ•°ï¼Œä¸‹é¢ä»£ç å‡ºè‡ªï¼šhttps://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/

```C++
ans += n;
std::vector<int> sort_plane{plane};
// record the final idx for num
std::unordered_map<int, int> map;
// çµç¥æ²¡æœ‰ä½¿ç”¨ map è€Œæ˜¯å¯¹ sort_plane ä½¿ç”¨äºŒåˆ†æœç´¢æ‰¾æ–°åæ ‡
sort(sort_plane.begin(), sort_plane.end());
for (int i = 0; i < sort_plane.size(); ++i) 
    map[sort_plane[i]] = i;
// build a visited arr
std::vector<bool> vis(n, false);
for (int i = 0; i < n; ++i) {
    if (vis[i]) continue;
    int j = i;
    while (!vis[j]) {
        vis[j] = true;
        j = map[plane[j]];
    }
    ans -= 1;
}
```

#### æ’åˆ—ä¸ç»„åˆ

å…¨æ’åˆ—ï¼šn ä¸ªå…ƒç´ çš„å…¨æ’åˆ—ä¸º $n!$ çš„é˜¶ä¹˜

æ’åˆ—å…¬å¼å¦‚ä¸‹ï¼š
$$
C_{n}^{m}=\frac{P_{n}^{m}}{P_{m}}=\frac{n !}{m !(n-m) !}, C_{n}^{0}=1
$$
æˆ–è€…ï¼š
$$
C_{n}^{m}=\frac{n(n-1)(n-2) \cdots(n-m+1)}{m!}
$$
ç»„åˆæ€»æ•°è®¡ç®—ä»£ç ï¼Œåœ¨ã€Šç®—æ³•/ç»„åˆæ•°ä¸­ã€‹æœ‰ä½¿ç”¨ dp è®¡ç®—ç»„åˆæ•°çš„ä»£ç 
